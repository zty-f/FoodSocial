## 1、需求分析 

### 1.1、说明

<img src="https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220103223335408.png" alt="image-20220103223335408" style="zoom: 33%;" />

### 1.2、表结构设计

#### 1.2.1、代金券表

```sql
CREATE TABLE `t_voucher`  (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '代金券标题',
  `thumbnail` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '缩略图',
  `amount` int(11) NULL DEFAULT NULL COMMENT '抵扣金额',
  `price` decimal(10, 2) NULL DEFAULT NULL COMMENT '售价',
  `status` int(10) NULL DEFAULT NULL COMMENT '-1=过期 0=下架 1=上架',
  `expire_time` datetime(0) NULL DEFAULT NULL COMMENT '过期时间',
  `redeem_restaurant_id` int(10) NULL DEFAULT NULL COMMENT '验证餐厅',
  `stock` int(11) NULL DEFAULT 0 COMMENT '库存',
  `stock_left` int(11) NULL DEFAULT 0 COMMENT '剩余数量',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述信息',
  `clause` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '使用条款',
  `create_date` datetime(0) NULL DEFAULT NULL,
  `update_date` datetime(0) NULL DEFAULT NULL,
  `is_valid` tinyint(1) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

```

#### 1.2.2、抢购活动表

```sql
DROP TABLE IF EXISTS `t_seckill_vouchers`;
CREATE TABLE `t_seckill_vouchers`  (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `fk_voucher_id` INT(11) NULL DEFAULT NULL,
  `amount` INT(11) NULL DEFAULT NULL,
  `start_time` DATETIME(0) NULL DEFAULT NULL,
  `end_time` DATETIME(0) NULL DEFAULT NULL,
  `is_valid` INT(11) NULL DEFAULT NULL,
  `create_date` DATETIME(0) NULL DEFAULT NULL,
  `update_date` DATETIME(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = INNODB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

```

#### 1.2.3、订单表

```sql
CREATE TABLE `t_voucher_order`  (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `order_no` INT(11) NULL DEFAULT NULL,
  `fk_voucher_id` INT(11) NULL DEFAULT NULL,
  `fk_diner_id` INT(11) NULL DEFAULT NULL,
  `qrcode` VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '图片地址',
  `payment` TINYINT(4) NULL DEFAULT NULL COMMENT '0=微信支付 1=支付宝支付',
  `status` TINYINT(1) NULL DEFAULT NULL COMMENT '订单状态：-1=已取消 0=未支付 1=已支付 2=已消费 3=已过期',
  `fk_seckill_id` INT(11) NULL DEFAULT NULL COMMENT '如果是抢购订单时，抢购订单的id',
  `order_type` INT(11) NULL DEFAULT NULL COMMENT '订单类型：0=正常订单 1=抢购订单',
  `create_date` DATETIME(0) NULL DEFAULT NULL,
  `update_date` DATETIME(0) NULL DEFAULT NULL,
  `is_valid` INT(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = INNODB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;
```

## 2、解决方案

## 3、创建服务 ms-seckill

### 3.1、添加依赖

```xml
<dependencies>
        <!-- eureka client -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!-- spring web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!-- mybatis -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
        </dependency>
        <!-- mysql -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <!-- spring data redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!-- commons -->
        <dependency>
            <groupId>com.imooc</groupId>
            <artifactId>commons</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson-spring-boot-starter</artifactId>
            <version>3.13.6</version>
        </dependency>
    </dependencies>
```

### 3.2、配置文件

```yml
server:
  port: 8083 # 端口

spring:
  application:
    name: ms-seckill # 应用名
  # 数据库
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: root
    url: jdbc:mysql://127.0.0.1:3306/db_imooc?serverTimezone=Asia/Shanghai&characterEncoding=utf8&useUnicode=true&useSSL=false
  # Redis
  redis:
    port: 6379
    host: 192.168.65.3
    timeout: 3000
    password: 123456
  # Swagger
  swagger:
    base-package: com.imooc.seckill
    title: 美食社交食客API接口文档

# 配置 Eureka Server 注册中心
eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.ip-address}:${server.port}
  client:
    service-url:
      defaultZone: http://localhost:8080/eureka/

mybatis:
  configuration:
    map-underscore-to-camel-case: true # 开启驼峰映射

service:
  name:
    ms-oauth-server: http://ms-oauth2-server/

logging:
  pattern:
    console: '%d{2100-01-01 13:14:00.666} [%thread] %-5level %logger{50} - %msg%n'
```

## 4、代码实现

### 4.1、相关实体类

#### 4.1.1、代金券订单

- `VoucherOrders.java `

```java
package com.xiao.commons.model.pojo;

import com.xiao.commons.model.base.BaseModel;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Getter;
import lombok.Setter;

@ApiModel(description = "代金券订单信息")
@Getter
@Setter
public class VoucherOrders extends BaseModel {

    @ApiModelProperty("订单编号")
    private String orderNo;
    @ApiModelProperty("代金券")
    private Integer fkVoucherId;
    @ApiModelProperty("下单用户")
    private Integer fkDinerId;
    @ApiModelProperty("生成qrcode")
    private String qrcode;
    @ApiModelProperty("支付方式 0=微信支付 1=支付宝")
    private int payment;
    @ApiModelProperty("订单状态 -1=已取消 0=未支付 1=已支付 2=已消费 3=已过期")
    private int status;
    @ApiModelProperty("订单类型 0=正常订单 1=抢购订单")
    private int orderType;
    @ApiModelProperty("抢购订单的外键")
    private int fkSeckillId;

}
```

#### 4.1.2、抢购代金券

- `SeckillVouchers.java` 

```java
package com.xiao.commons.model.pojo;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.xiao.commons.model.base.BaseModel;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Getter;
import lombok.Setter;
import org.springframework.format.annotation.DateTimeFormat;

import java.util.Date;

@Setter
@Getter
@ApiModel(description = "抢购代金券信息")
public class SeckillVouchers extends BaseModel {

    @ApiModelProperty("代金券外键")
    private Integer fkVoucherId;
    @ApiModelProperty("数量")
    private int amount;
    @ApiModelProperty("抢购开始时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm", timezone = "GMT+8")
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm")
    private Date startTime;
    @ApiModelProperty("抢购结束时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm", timezone = "GMT+8")
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm")
    private Date endTime;

}
```

### 4.2、相关配置类

#### 4.2.1、Rest配置类 

- `RestTemplateConfiguration.java`

```java
package com.xiao.seckill.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.client.RestTemplate;

import java.util.Collections;

@Configuration
public class RestTemplateConfiguration {

    @LoadBalanced
    @Bean
    public RestTemplate restTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        converter.setSupportedMediaTypes(Collections.singletonList(MediaType.TEXT_PLAIN));
        restTemplate.getMessageConverters().add(converter);
        return restTemplate;
    }
    
}
```

### 4.3、全局异常处理

- `GlobalExceptionHandler.java`

```java
package com.xiao.seckill.handler;

import com.xiao.commons.exception.ParameterException;
import com.xiao.commons.model.domain.ResultInfo;
import com.xiao.commons.utils.ResultInfoUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import java.util.Map;

@RestControllerAdvice // 将输出的内容写入 ResponseBody 中
@Slf4j
public class GlobalExceptionHandler {

    @Resource
    private HttpServletRequest request;

    @ExceptionHandler(ParameterException.class)
    public ResultInfo<Map<String, String>> handlerParameterException(ParameterException ex) {
        String path = request.getRequestURI();
        ResultInfo<Map<String, String>> resultInfo =
                ResultInfoUtil.buildError(ex.getErrorCode(), ex.getMessage(), path);
        return resultInfo;
    }

    @ExceptionHandler(Exception.class)
    public ResultInfo<Map<String, String>> handlerException(Exception ex) {
        log.info("未知异常：{}", ex);
        String path = request.getRequestURI();
        ResultInfo<Map<String, String>> resultInfo =
                ResultInfoUtil.buildError(path);
        return resultInfo;
    }

}
```

### 4.4、添加秒杀活动

#### 4.4.1、Mapper层

```java
package com.xiao.seckill.mapper;

import com.xiao.commons.model.pojo.SeckillVouchers;
import org.apache.ibatis.annotations.*;

/**
 * 秒杀代金券 Mapper
 */
public interface SeckillVouchersMapper {

    // 新增秒杀活动
    @Insert("insert into t_seckill_vouchers (fk_voucher_id, amount, start_time, end_time, is_valid, create_date, update_date) " +
            " values (#{fkVoucherId}, #{amount}, #{startTime}, #{endTime}, 1, now(), now())")
    @Options(useGeneratedKeys = true, keyProperty = "id")
    int save(SeckillVouchers seckillVouchers);

     // 根据代金券 ID 查询该代金券是否参与抢购活动
    @Select("select id, fk_voucher_id, amount, start_time, end_time, is_valid " +
            " from t_seckill_vouchers where fk_voucher_id = #{voucherId}")
    SeckillVouchers selectVoucher(Integer voucherId);
}
```

#### 4.4.2、Service层

```java
package com.xiao.seckill.service;

import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.IdUtil;
import com.xiao.commons.constant.ApiConstant;
import com.xiao.commons.constant.RedisKeyConstant;
import com.xiao.commons.exception.ParameterException;
import com.xiao.commons.model.domain.ResultInfo;
import com.xiao.commons.model.pojo.SeckillVouchers;
import com.xiao.commons.model.pojo.VoucherOrders;
import com.xiao.commons.model.vo.SignInDinerInfo;
import com.xiao.commons.utils.AssertUtil;
import com.xiao.commons.utils.ResultInfoUtil;
import com.xiao.seckill.mapper.SeckillVouchersMapper;
import com.xiao.seckill.mapper.VoucherOrdersMapper;
import com.xiao.seckill.model.RedisLock;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.interceptor.TransactionAspectSupport;
import org.springframework.web.client.RestTemplate;

import javax.annotation.Resource;
import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * 秒杀业务逻辑层
 */
@Service
public class SeckillService {

    @Resource
    private SeckillVouchersMapper seckillVouchersMapper;
    @Resource
    private VoucherOrdersMapper voucherOrdersMapper;
    @Value("${service.name.ms-oauth-server}")
    private String oauthServerName;
    @Resource
    private RestTemplate restTemplate;
    @Resource
    private RedisTemplate redisTemplate;
    @Resource
    private DefaultRedisScript defaultRedisScript;
    @Resource
    private RedisLock redisLock;
    @Resource
    private RedissonClient redissonClient;

  
    /**
     * 添加需要抢购的代金券
     *
     * @param seckillVouchers
     */
    @Transactional(rollbackFor = Exception.class)
    public void addSeckillVouchers(SeckillVouchers seckillVouchers) {
        // 非空校验
        AssertUtil.isTrue(seckillVouchers.getFkVoucherId() == null, "请选择需要抢购的代金券");
        AssertUtil.isTrue(seckillVouchers.getAmount() == 0, "请输入抢购总数量");
        Date now = new Date();
        AssertUtil.isNotNull(seckillVouchers.getStartTime(), "请输入开始时间");
        // 生产环境下面一行代码需放行，这里注释方便测试
        // AssertUtil.isTrue(now.after(seckillVouchers.getStartTime()), "开始时间不能早于当前时间");
        AssertUtil.isNotNull(seckillVouchers.getEndTime(), "请输入结束时间");
        AssertUtil.isTrue(now.after(seckillVouchers.getEndTime()), "结束时间不能早于当前时间");
        AssertUtil.isTrue(seckillVouchers.getStartTime().after(seckillVouchers.getEndTime()), "开始时间不能晚于结束时间");

        
        // 验证数据库中是否已经存在该券的秒杀活动
         SeckillVouchers seckillVouchersFromDb = seckillVouchersMapper.selectVoucher(seckillVouchers.getFkVoucherId());
         AssertUtil.isTrue(seckillVouchersFromDb != null, "该券已经拥有了抢购活动");
        // 插入数据库
         seckillVouchersMapper.save(seckillVouchers);       
}
```

#### 4.4.3、Controller层

```java
package com.xiao.seckill.controller;

import com.xiao.commons.model.domain.ResultInfo;
import com.xiao.commons.model.pojo.SeckillVouchers;
import com.xiao.commons.utils.ResultInfoUtil;
import com.xiao.seckill.service.SeckillService;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;

/**
 * 秒杀控制层
 */
@RestController
public class SeckillController {

    @Resource
    private SeckillService seckillService;
    @Resource
    private HttpServletRequest request;

    /**
     * 新增秒杀活动
     *
     * @param seckillVouchers
     * @return
     */
    @PostMapping("add")
    public ResultInfo<String> addSeckillVouchers(@RequestBody SeckillVouchers seckillVouchers) {
        seckillService.addSeckillVouchers(seckillVouchers);
        return ResultInfoUtil.buildSuccess(request.getServletPath(),
                "添加成功");
    }

}
```

#### 4.4.4、启动类

```java
package com.xiao.seckill;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@MapperScan("com.imooc.seckill.mapper")
@SpringBootApplication
public class SeckillApplication {

    public static void main(String[] args) {
        SpringApplication.run(SeckillApplication.class);
    }

}
```

#### 4.4.5、测试

我们打开`PostMan`，进行添加秒杀活动。

访问地址：http://localhost:8083/add

JSON参数:

```json
{
    "fkVoucherId" : 1,
    "amount":100,
    "startTime": "2022-01-04 11:30:30",
    "endTime":"2022-02-04 11:30:30" 
}
```

![image-20220104204010711](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220104204010711.png)

打开`t_seckill_vouchers`表，查看信息，添加秒杀活动成功！

![image-20220104204102904](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220104204102904.png)

### 4.5、客户端秒杀

#### 4.5.1、Mapper层

- `SeckillVouchersMapper.java` 

```java
package com.xiao.seckill.mapper;

import com.xiao.commons.model.pojo.SeckillVouchers;
import org.apache.ibatis.annotations.*;

/**
 * 秒杀代金券 Mapper
 */
public interface SeckillVouchersMapper {

    // 新增秒杀活动
    @Insert("insert into t_seckill_vouchers (fk_voucher_id, amount, start_time, end_time, is_valid, create_date, update_date) " +
            " values (#{fkVoucherId}, #{amount}, #{startTime}, #{endTime}, 1, now(), now())")
    @Options(useGeneratedKeys = true, keyProperty = "id")
    int save(SeckillVouchers seckillVouchers);
    
    // 根据代金券 ID 查询该代金券是否参与抢购活动
    @Select("select id, fk_voucher_id, amount, start_time, end_time, is_valid " +
            " from t_seckill_vouchers where fk_voucher_id = #{voucherId}")
    SeckillVouchers selectVoucher(Integer voucherId);

    // 减库存
    @Update("update t_seckill_vouchers set amount = amount - 1 " +
            " where id = #{seckillId}")
    int stockDecrease(@Param("seckillId") int seckillId);

}
```

- `VoucherOrdersMapper.java`

```java
package com.xiao.seckill.mapper;

import com.xiao.commons.model.pojo.VoucherOrders;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Select;

/**
 * 代金券订单 Mapper
 */
public interface VoucherOrdersMapper {

    // 根据食客 ID 和秒杀 ID 查询代金券订单
    @Select("select id, order_no, fk_voucher_id, fk_diner_id, qrcode, payment," +
            " status, fk_seckill_id, order_type, create_date, update_date, " +
            " is_valid from t_voucher_orders where fk_diner_id = #{dinerId} " +
            " and fk_voucher_id = #{voucherId} and is_valid = 1 and status between 0 and 1 ")
    VoucherOrders findDinerOrder(@Param("dinerId") Integer dinerId,
                                 @Param("voucherId") Integer voucherId);

    // 新增代金券订单
    @Insert("insert into t_voucher_orders (order_no, fk_voucher_id, fk_diner_id, " +
            " status, fk_seckill_id, order_type, create_date, update_date,  is_valid)" +
            " values (#{orderNo}, #{fkVoucherId}, #{fkDinerId}, #{status}, #{fkSeckillId}, " +
            " #{orderType}, now(), now(), 1)")
    int save(VoucherOrders voucherOrders);

}
```



#### 4.5.1、Service层

- 基本参数校验
- 判断此代金券是否加入抢购
- 判断是否有效
- 判断是否开始，结束
- 判断是否卖完
- 获取登录用户信息
- 判断登录用户是否抢到（一个用户针对这次活动只能买一次）
- 扣库存
- 下单

```java
package com.xiao.seckill.service;

import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.IdUtil;
import com.xiao.commons.constant.ApiConstant;
import com.xiao.commons.constant.RedisKeyConstant;
import com.xiao.commons.exception.ParameterException;
import com.xiao.commons.model.domain.ResultInfo;
import com.xiao.commons.model.pojo.SeckillVouchers;
import com.xiao.commons.model.pojo.VoucherOrders;
import com.xiao.commons.model.vo.SignInDinerInfo;
import com.xiao.commons.utils.AssertUtil;
import com.xiao.commons.utils.ResultInfoUtil;
import com.xiao.seckill.mapper.SeckillVouchersMapper;
import com.xiao.seckill.mapper.VoucherOrdersMapper;
import com.xiao.seckill.model.RedisLock;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.interceptor.TransactionAspectSupport;
import org.springframework.web.client.RestTemplate;

import javax.annotation.Resource;
import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * 秒杀业务逻辑层
 */
@Service
public class SeckillService {

    @Resource
    private SeckillVouchersMapper seckillVouchersMapper;
    @Resource
    private VoucherOrdersMapper voucherOrdersMapper;
    @Value("${service.name.ms-oauth-server}")
    private String oauthServerName;
    @Resource
    private RestTemplate restTemplate;

    /**
     * 抢购代金券
     *
     * @param voucherId   代金券 ID
     * @param accessToken 登录token
     * @Para path 访问路径
     */
    @Transactional(rollbackFor = Exception.class)
    public ResultInfo doSeckill(Integer voucherId, String accessToken, String path) {
        // 基本参数校验
        AssertUtil.isTrue(voucherId == null || voucherId < 0, "请选择需要抢购的代金券");
        AssertUtil.isNotEmpty(accessToken, "请登录");

        // 注释原始的 关系型数据库 的流程
        // 判断此代金券是否加入抢购
         SeckillVouchers seckillVouchers = seckillVouchersMapper.selectVoucher(voucherId);
         AssertUtil.isTrue(seckillVouchers == null, "该代金券并未有抢购活动");
        // 判断是否有效
         AssertUtil.isTrue(seckillVouchers.getIsValid() == 0, "该活动已结束");
         

        // 判断是否开始、结束
        Date now = new Date();
        AssertUtil.isTrue(now.before(seckillVouchers.getStartTime()), "该抢购还未开始");
        AssertUtil.isTrue(now.after(seckillVouchers.getEndTime()), "该抢购已结束");
        // 判断是否卖完
        AssertUtil.isTrue(seckillVouchers.getAmount() < 1, "该券已经卖完了");
        // 获取登录用户信息
        String url = oauthServerName + "user/me?access_token={accessToken}";
        ResultInfo resultInfo = restTemplate.getForObject(url, ResultInfo.class, accessToken);
        if (resultInfo.getCode() != ApiConstant.SUCCESS_CODE) {
            resultInfo.setPath(path);
            return resultInfo;
        }
        // 这里的data是一个LinkedHashMap，SignInDinerInfo
        SignInDinerInfo dinerInfo = BeanUtil.fillBeanWithMap((LinkedHashMap) resultInfo.getData(),
                new SignInDinerInfo(), false);
        // 判断登录用户是否已抢到(一个用户针对这次活动只能买一次)
        VoucherOrders order = voucherOrdersMapper.findDinerOrder(dinerInfo.getId(),
                seckillVouchers.getFkVoucherId());
        AssertUtil.isTrue(order != null, "该用户已抢到该代金券，无需再抢");
        
        // 扣库存
        int count = seckillVouchersMapper.stockDecrease(seckillVouchers.getId());
        AssertUtil.isTrue(count == 0, "该券已经卖完了");
        
        // 下单
        VoucherOrders voucherOrders = new VoucherOrders();
        voucherOrders.setFkDinerId(dinerInfo.getId());
        voucherOrders.setFkSeckillId(seckillVouchers.getId());
        voucherOrders.setFkVoucherId(seckillVouchers.getFkVoucherId());
        String orderNo = IdUtil.getSnowflake(1, 1).nextIdStr();
        voucherOrders.setOrderNo(orderNo);
        voucherOrders.setOrderType(1);
        voucherOrders.setStatus(0);
        count = voucherOrdersMapper.save(voucherOrders);
        AssertUtil.isTrue(count == 0, "用户抢购失败");
       
        return ResultInfoUtil.buildSuccess(path, "抢购成功");
    }

    /**
     * 添加需要抢购的代金券
     *
     * @param seckillVouchers
     */
    @Transactional(rollbackFor = Exception.class)
    public void addSeckillVouchers(SeckillVouchers seckillVouchers) {
        // 非空校验
        AssertUtil.isTrue(seckillVouchers.getFkVoucherId() == null, "请选择需要抢购的代金券");
        AssertUtil.isTrue(seckillVouchers.getAmount() == 0, "请输入抢购总数量");
        Date now = new Date();
        AssertUtil.isNotNull(seckillVouchers.getStartTime(), "请输入开始时间");
        // 生产环境下面一行代码需放行，这里注释方便测试
        // AssertUtil.isTrue(now.after(seckillVouchers.getStartTime()), "开始时间不能早于当前时间");
        AssertUtil.isNotNull(seckillVouchers.getEndTime(), "请输入结束时间");
        AssertUtil.isTrue(now.after(seckillVouchers.getEndTime()), "结束时间不能早于当前时间");
        AssertUtil.isTrue(seckillVouchers.getStartTime().after(seckillVouchers.getEndTime()), "开始时间不能晚于结束时间");

        // 注释原始的走 关系型数据库 的流程
        // 验证数据库中是否已经存在该券的秒杀活动
         SeckillVouchers seckillVouchersFromDb = seckillVouchersMapper.selectVoucher(seckillVouchers.getFkVoucherId());
         AssertUtil.isTrue(seckillVouchersFromDb != null, "该券已经拥有了抢购活动");
        // 插入数据库
         seckillVouchersMapper.save(seckillVouchers);

        /*// 采用 Redis 实现
        String key = RedisKeyConstant.seckill_vouchers.getKey() +
                seckillVouchers.getFkVoucherId();
        // 验证 Redis 中是否已经存在该券的秒杀活动
        Map<String, Object> map = redisTemplate.opsForHash().entries(key);
        AssertUtil.isTrue(!map.isEmpty() && (int) map.get("amount") > 0, "该券已经拥有了抢购活动");

        // 插入 Redis
        seckillVouchers.setIsValid(1);
        seckillVouchers.setCreateDate(now);
        seckillVouchers.setUpdateDate(now);
        redisTemplate.opsForHash().putAll(key, BeanUtil.beanToMap(seckillVouchers));*/
    }

}
```

#### 4.5.2、Controller层

```java
	 /**
     * 秒杀下单
     *
     * @param voucherId
     * @param access_token
     * @return
     */
    @PostMapping("{voucherId}")
    public ResultInfo<String> doSeckill(@PathVariable Integer voucherId, String access_token) {
        ResultInfo resultInfo = seckillService.doSeckill(voucherId, access_token, request.getServletPath());
        return resultInfo;
    }
```

## 5、压力测试

Windows环境下使用JMter5.3模拟抢购场景。

### 5.1、下载Jmeter5.0工具

下载地址：https://jmeter.apache.org/download_jmeter.cgi

![image-20220104213818637](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220104213818637.png)

### 5.2、解压启动

解压文件，打开bin目录，点击`jmeter.bat`脚本文件进行启动。

![image-20220104214706931](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220104214706931.png)

### 5.3、配置中文语言

![image-20220104214845831](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220104214845831.png)

### 5.4、生成登录token

打开`ms-oauth2-server`模块。

修改`OAuth2ServerApplicationTests`，添加mock测试客户端

```java
package com.xiao.oauth2.server;

import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;

import javax.annotation.Resource;

@SpringBootTest
@AutoConfigureMockMvc
public class OAuth2ServerApplicationTests {

    @Resource
    protected MockMvc mockMvc;

}
```

创建`OAuthControllerTest ` 生成token，文件存在于根目录下。

```java
package com.xiao.oauth2.server.controller;

import cn.hutool.json.JSONObject;
import cn.hutool.json.JSONUtil;
import com.xiao.commons.model.domain.ResultInfo;
import com.xiao.oauth2.server.OAuth2ServerApplicationTests;
import org.junit.jupiter.api.Test;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.util.Base64Utils;

import java.nio.file.Files;
import java.nio.file.Paths;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

public class OAuthControllerTest extends OAuth2ServerApplicationTests {

    @Test
    public void writeToken() throws Exception {
        String authorization = Base64Utils.encodeToString("appId:123456".getBytes());
        StringBuffer tokens = new StringBuffer();
        for (int i = 0; i < 2000; i++) {
            MvcResult mvcResult = super.mockMvc.perform(MockMvcRequestBuilders.post("/oauth/token")
                    .header("Authorization", "Basic " + authorization)
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                    .param("username", "test" + i)
                    .param("password", "123456")
                    .param("grant_type", "password")
                    .param("scope", "api")
            )
                    .andExpect(status().isOk())
                    // .andDo(print())
                    .andReturn();
            String contentAsString = mvcResult.getResponse().getContentAsString();
            ResultInfo resultInfo = (ResultInfo) JSONUtil.toBean(contentAsString, ResultInfo.class);
            JSONObject result = (JSONObject) resultInfo.getData();
            String token = result.getStr("accessToken");
            tokens.append(token).append("\r\n");
        }

        Files.write(Paths.get("tokens.txt"), tokens.toString().getBytes());
    }

}
```

运行`OAuthControllerTest`，生成token

![image-20220104220609390](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220104220609390.png)

并将token写入`tokens.txt`。

![image-20220104220709580](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220104220709580.png)

### 5.5、导入测试计划

**导入测试计划** 

![image-20220104220750616](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220104220750616.png)

**配置token.txt路径** 

![image-20220104220851719](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220104220851719.png)

**进行测试** 

1、多人抢购代金券：模拟5000个并发，2000个账号进行抢购

**结果：数据库中 t_seckill_vouchers 表的 amount 会变成负数（超卖了），t_vouchers_orders 的订单会超过100，说明卖多了**



![img](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/1615385831891-2a9a2850-419c-40da-b92d-7d6b9410d76b.png)



![img](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/1615385839891-798a262a-b485-4598-9702-199da39c9606.png)



![img](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/1615385848740-3792a549-5146-497e-86b8-e698c8fa2c2b.png)

2、模拟某个用户多次抢购：模拟10000个并发，一个账号进行抢购

![img](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/1615385887639-8a145610-650b-42de-aeac-24c6cfb60e7f.png)

**结果后台会报错，同时订单表会针对一个 voucher 一个用户多个订单**

先 `TRUNCATE t_voucher_orders` 清空数据，修改` t_seckill_vouchers amount` 为100



<img src="https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/1615385966339-f8e3d9aa-2972-4cca-9a70-520d02106133.png" alt="img" style="zoom:50%;" />

## 6、Redis防止超卖

### 6.1、解决思路

- 将活动写入Redis中，通过Redis自减指令扣除库存。

#### 6.1.1、RedisConstant

```java
package com.xiao.commons.constant;

import lombok.Getter;

@Getter
public enum RedisKeyConstant {

    verify_code("verify_code:", "验证码"),
    seckill_vouchers("seckill_vouchers:", "秒杀券的key"),
  
    private String key;
    private String desc;

    RedisKeyConstant(String key, String desc) {
        this.key = key;
        this.desc = desc;
    }

}
```

#### 6.1.2、Redis配置类

```java
package com.xiao.seckill.config;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisTemplateConfiguration {

    /**
     * redisTemplate 序列化使用的jdkSerializeable, 存储二进制字节码, 所以自定义序列化类
     *
     * @param redisConnectionFactory
     * @return
     */
    @Bean
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);

        // 使用Jackson2JsonRedisSerialize 替换默认序列化
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);

        // 设置key和value的序列化规则
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.setKeySerializer(new StringRedisSerializer());

        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);

        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }

    @Bean
    public DefaultRedisScript<Long> stockScript() {
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        //放在和application.yml 同层目录下
        redisScript.setLocation(new ClassPathResource("stock.lua"));
        redisScript.setResultType(Long.class);
        return redisScript;
    }

}
```

### 6.2、修改添加活动的业务

```java
/**
     * 添加需要抢购的代金券
     *
     * @param seckillVouchers
     */
    @Transactional(rollbackFor = Exception.class)
    public void addSeckillVouchers(SeckillVouchers seckillVouchers) {
        // 非空校验
        AssertUtil.isTrue(seckillVouchers.getFkVoucherId() == null, "请选择需要抢购的代金券");
        AssertUtil.isTrue(seckillVouchers.getAmount() == 0, "请输入抢购总数量");
        Date now = new Date();
        AssertUtil.isNotNull(seckillVouchers.getStartTime(), "请输入开始时间");
        // 生产环境下面一行代码需放行，这里注释方便测试
        // AssertUtil.isTrue(now.after(seckillVouchers.getStartTime()), "开始时间不能早于当前时间");
        AssertUtil.isNotNull(seckillVouchers.getEndTime(), "请输入结束时间");
        AssertUtil.isTrue(now.after(seckillVouchers.getEndTime()), "结束时间不能早于当前时间");
        AssertUtil.isTrue(seckillVouchers.getStartTime().after(seckillVouchers.getEndTime()), "开始时间不能晚于结束时间");

        // 注释原始的走 关系型数据库 的流程
        // 验证数据库中是否已经存在该券的秒杀活动
        // SeckillVouchers seckillVouchersFromDb = seckillVouchersMapper.selectVoucher(seckillVouchers.getFkVoucherId());
        // AssertUtil.isTrue(seckillVouchersFromDb != null, "该券已经拥有了抢购活动");
        // 插入数据库
        // seckillVouchersMapper.save(seckillVouchers);

        // 采用 Redis 实现
        String key = RedisKeyConstant.seckill_vouchers.getKey() +
                seckillVouchers.getFkVoucherId();
        // 验证 Redis 中是否已经存在该券的秒杀活动
        Map<String, Object> map = redisTemplate.opsForHash().entries(key);
        AssertUtil.isTrue(!map.isEmpty() && (int) map.get("amount") > 0, "该券已经拥有了抢购活动");

        // 插入 Redis
        seckillVouchers.setIsValid(1);
        seckillVouchers.setCreateDate(now);
        seckillVouchers.setUpdateDate(now);
        redisTemplate.opsForHash().putAll(key, BeanUtil.beanToMap(seckillVouchers));
    }
```

### 6.3、修改抢购业务

```java
/**
     * 抢购代金券
     *
     * @param voucherId   代金券 ID
     * @param accessToken 登录token
     * @Para path 访问路径
     */
    @Transactional(rollbackFor = Exception.class)
    public ResultInfo doSeckill(Integer voucherId, String accessToken, String path) {
        // 基本参数校验
        AssertUtil.isTrue(voucherId == null || voucherId < 0, "请选择需要抢购的代金券");
        AssertUtil.isNotEmpty(accessToken, "请登录");

        // 注释原始的 关系型数据库 的流程
        // 判断此代金券是否加入抢购
        // SeckillVouchers seckillVouchers = seckillVouchersMapper.selectVoucher(voucherId);
        // AssertUtil.isTrue(seckillVouchers == null, "该代金券并未有抢购活动");
        // 判断是否有效
        // AssertUtil.isTrue(seckillVouchers.getIsValid() == 0, "该活动已结束");

        // 采用 Redis
        String key = RedisKeyConstant.seckill_vouchers.getKey() + voucherId;
        Map<String, Object> map = redisTemplate.opsForHash().entries(key);
        SeckillVouchers seckillVouchers = BeanUtil.mapToBean(map, SeckillVouchers.class, true, null);

        // 判断是否开始、结束
        Date now = new Date();
        AssertUtil.isTrue(now.before(seckillVouchers.getStartTime()), "该抢购还未开始");
        AssertUtil.isTrue(now.after(seckillVouchers.getEndTime()), "该抢购已结束");
        // 判断是否卖完
        AssertUtil.isTrue(seckillVouchers.getAmount() < 1, "该券已经卖完了");
        // 获取登录用户信息
        String url = oauthServerName + "user/me?access_token={accessToken}";
        ResultInfo resultInfo = restTemplate.getForObject(url, ResultInfo.class, accessToken);
        if (resultInfo.getCode() != ApiConstant.SUCCESS_CODE) {
            resultInfo.setPath(path);
            return resultInfo;
        }
        // 这里的data是一个LinkedHashMap，SignInDinerInfo
        SignInDinerInfo dinerInfo = BeanUtil.fillBeanWithMap((LinkedHashMap) resultInfo.getData(),
                new SignInDinerInfo(), false);
        // 判断登录用户是否已抢到(一个用户针对这次活动只能买一次)
        VoucherOrders order = voucherOrdersMapper.findDinerOrder(dinerInfo.getId(),
                seckillVouchers.getFkVoucherId());
        AssertUtil.isTrue(order != null, "该用户已抢到该代金券，无需再抢");

        // 注释原始的 关系型数据库 的流程
        // 扣库存
        // int count = seckillVouchersMapper.stockDecrease(seckillVouchers.getId());
        // AssertUtil.isTrue(count == 0, "该券已经卖完了");

        // 采用 Redis
        // 扣库存
        long count = redisTemplate.opsForHash().increment(key, "amount", -1);
        AssertUtil.isTrue(count < 0, "该券已经卖完了");

        // 下单
        VoucherOrders voucherOrders = new VoucherOrders();
        voucherOrders.setFkDinerId(dinerInfo.getId());
        // Redis 中不需要维护外键信息
        // voucherOrders.setFkSeckillId(seckillVouchers.getId());
        voucherOrders.setFkVoucherId(seckillVouchers.getFkVoucherId());
        String orderNo = IdUtil.getSnowflake(1, 1).nextIdStr();
        voucherOrders.setOrderNo(orderNo);
        voucherOrders.setOrderType(1);
        voucherOrders.setStatus(0);
        AssertUtil.isTrue(count == 0, "用户抢购失败");

        return ResultInfoUtil.buildSuccess(path, "抢购成功");
    }

```

### 6.4、测试

**问题一，多扣库存问题**

打开PostMan进行测试，测试地址：http://localhost:8083/add

参数

```json
{
    "fkVoucherId" : 1,
    "amount":100,
    "startTime": "2022-01-04 11:30:30",
    "endTime":"2022-02-04 11:30:30" 
}
```

![image-20220105110455090](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220105110455090.png)

测试成功！

打开Jmeter进行压力测试，出现多扣库存！

![image-20220105111209634](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/image-20220105111209634.png)

![img](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/1615386211225-0a43f9b0-0ae2-4260-9028-336e095a5bf7.png)

分析：因为 Redis 在扣 库存时抛出了 `该卷已经卖完了` 的异常，导致后续代码不再执行所以订单是符合逻辑的

解决：那可能大部分的人都会想到，直接把 Redis 扣库存的代码放在下单后执行不就行了，我们来试一试

**问题二，超卖及多扣库存问题**

![img](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/1615386333205-7d11b3bc-2175-46e9-8198-1fb029590636.png)

分析：虽然 Redis 在扣除库存时跑出了 `该卷已经卖完了` 的一场，但是由于方法没有事务的一场回滚处理，订单也出现了超卖的问题

解决：添加事务，我们再来试一试

**问题三，多扣库存问题**

![img](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/1615386419986-ec996d2e-74af-4074-bdd4-f3002f136717.png)



![img](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/1615386427193-49c4a29a-668b-49ae-90d1-96de099f3ec2.png)



分析：我们发现，又回到问题一的老样子了。此时是因为 Redis 在扣除库存时抛出了 `该卷已经卖完了` 的异常，由于方法没有事务的异常回滚处理，所以订单是符合逻辑的，但是 Redis 却还在扣除库存。因为 Redis 这里实际上是一个查询库存，再扣除库存的操作，并发场景下仍然会出现问题，我们只需要两个操作在同一个线程中执行即可，也就是保证它的原子性

## 7、Lua脚本

在减库存时，使用的lua脚本操作了Redis，因为减库存时，我们需要判断系统库存够不够，然后才能减掉，这里是两个操作，如果分开独立执行，那么有可能会出现错误（因为客户端是多线程)，因此我们采用lua脚本将两步操作放到一起同时在Redis中执行(Redis是单线程操作，故不会出现安全问题)。

将`stock.lua`脚本放到`resources`文件夹下：

```java
if (redis.call('hexists', KEYS[1], KEYS[2]) == 1) then
	local stock = tonumber(redis.call('hget', KEYS[1], KEYS[2]));
	if (stock > 0) then
	   redis.call('hincrby', KEYS[1], KEYS[2], -1);
	   return stock;
	end;
    return 0;
end;
```

在Redis配置类中配置以下代码

```java
@Bean
public DefaultRedisScript<Long> stockScript() {
    DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
    //放在和application.yml 同层目录下
    redisScript.setLocation(new ClassPathResource("stock.lua"));
    redisScript.setResultType(Long.class);
    return redisScript;
}
```

## 8、Redis限制一人一单

- 采用Redis分布式锁限制食客

### 8.1、锁的产生

**锁是一种保护机制，在多线程的情况下，保证数据操作的一致性。**

### 8.2、分布式锁实现

方式有三种：基于数据库; 基于Zookeeper调度中心;  **基于Redis**

### 8.3、分布式锁条件

**实现分布式锁要满足3点:多进程可见，互斥，可重入。**

#### 8.3.1.多进程可见

Redis本身就是基于JVM之外的，因此满足多进程可见的要求。

#### 8.3.2.互斥

同一时间只能有一个进程获取锁标记，我们可以通过redis的setnx实现，只有第一次执行的才会成功并返回1，其它情况返回0。`setnx key value`将key设置值为value，如果key不存在，这种情况下等同SET命令。当key存在时，什么也不做。SETNX是”SET if Not eXists”的简写。

`setnx`:  **已存在就不会改变键的值** 

```shell
# 第一次设置lock，成功返回1
192.168.65.3:2>setnx test abc
"1"
# 如果存在，再次设置会返回0
192.168.65.3:2>setnx test 123
"0"
192.168.65.3:2>del test
"1"
192.168.65.3:2>setnx test 123
"1"
```

**8.3.2.1、解决死锁**

但是使用setnx命令设置锁会出现死锁情况，比如当我get lock以后出现了异常以后并没有将锁删除，而且这把锁也没有过期时间，因此其他请求就再也获取不到这把锁了，这就是死锁。于是，后来Redis对 set 指令进行了改进，可以添加过期时间。当然有人会使用expire 指令将key进行过期，但这样就不能保证setnx和expire 的原子操作了。

```shell
SET KEY VALUE EX [seconds] PX [milliseconds] NX XX

# EX seconds -设置键key的过期时间，单位时秒
# PX milliseconds -设置键key的过期时间，单位时毫秒
# NX - 只有键不在的时候才会设置key的值
# XX - 只有键key存在的时候才会设置key的值
```

**因此set lock 123 EX 60 NX == setnx lock 123 + expire lock 60，而且set是原子操作，因此如果使用最简单的Redis分布式锁的话就可以使用set指令** 

代码如下：

```java
package com.imooc.demo01;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.params.SetParams;

public class RedisLock {

    private static final String LOCK_SUCCESS = "OK";
    private static final long UNLOCK_SUCCESS = 1L;

    /**
     * 尝试获取分布式锁
     *
     * @param jedis      Redis客户端
     * @param lockKey    锁
     * @param value      锁的值
     * @param expireTime 超期时间
     * @return 是否获取成功
     */
    public static boolean tryLock(Jedis jedis, String lockKey,
                                  String value, int expireTime) {
        // 自旋锁
        while (true) {
            // set key value ex seconds nx(只有键不存在的时候才会设置key)
            String result = jedis.set(lockKey, value,
                    SetParams.setParams().ex(expireTime).nx());
            if (LOCK_SUCCESS.equals(result)) {
                return true;
            }
        }
    }

    /**
     * 释放分布式锁
     *
     * @param jedis   Redis客户端
     * @param lockKey 锁
     * @return 是否释放成功
     */
    public static boolean unlock(Jedis jedis, String lockKey) {
        Long result = jedis.del(lockKey);
        if (UNLOCK_SUCCESS == result) {
            return true;
        }
        return false;
    }

}
```

### 8.4、可重入锁

重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。可重入锁的意义在于防止死锁。

**实现原理**是通过为每个锁关联一个请求计数器和一个占有它的线程。当计数为0时，认为锁是未被占有的;线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1。

如果同一个线程再次请求这个锁，计数将递增;每次占用线程退出同步块，计数器值将递减。直到计数器为0,锁被释放。

关于父类和子类的锁的重入:子类覆写了父类的synchonized方法，然后调用父类中的方法，此时如果没有重入的锁，那么这段代码将产生死锁。 

```java
package com.imooc.reentrant;

/**
 * 为每个锁关联一个请求计数器和一个占有它的线程。
 * 当计数为0时，认为锁是未被占有的；
 * 线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1 。
 */
public class ReentrantLock {

    boolean isLocked = false;
    Thread lockBy = null; // 独占线程
    int lockedCount = 0; // 计数器

    public synchronized void lock() throws InterruptedException {
        Thread thread = Thread.currentThread();
        while (isLocked && lockBy != thread) { // 判断加锁，而且线程不是当前线程
            wait();
        }
        isLocked = true;
        lockedCount++; // 计数器 +1
        lockBy = thread;

    }

    public synchronized void unlock() {
        if (Thread.currentThread() == this.lockBy) { // 判断是否是当前线程
            lockedCount--;
            if (lockedCount == 0) {  // 计数器为0时，释放锁
                isLocked = false;
                notify();
            }
        }
    }

}
```

### 8.5、Redis设计可冲入锁

#### 8.5.1、设计思路

```
假设锁的key为” lock "，hashKey是当前线程的id: " threadId "，锁自动释放时间假设为20
获取锁的步骤:
	1、判断lock是否存在 EXISTS lock
		2、不存在，则自己获取锁，记录重入层数为1.
		2、存在，说明有人获取锁了，下面判断是不是自己的锁，即判断当前线程id作为hashKey是否存在:HEXISTS lock
	threadId
		3、不存在，说明锁已经有了，且不是自己获取的，锁获取失败.
		3、存在，说明是自己获取的锁，重入次数+1: HINCRBY lock threadId 1 ，最后更新锁自动释放时间，EXPIRE
lock 20

释放锁的步骤:
		1、判断当前线程id作为hashKey是否存在:HEXISTS lock threadId
			2、不存在，说明锁已经失效，不用管了
			2、存在，说明锁还在，重入次数减1:HINCRBY lock threadId -1 ，
				3、获取新的重入次数，判断重入次数是否为0，为8说明锁全部释放，删除key: DEL lock

```

因此，存储在锁中的信息就必须包含: key、线程标识、重入次数。不能再使用简单的key-value结构，这里推荐使用hash结构。而且要让所有指令都在同一个线程中操作，那么使用lua脚本。

**设计 lock.lua 脚本** 

```lua
local key = KEYS[1]; -- 第1个参数,锁的key
local threadId = ARGV[1]; -- 第2个参数,线程唯一标识
local releaseTime = ARGV[2]; -- 第3个参数,锁的自动释放时间

if(redis.call('exists', key) == 0) then -- 判断锁是否已存在
    redis.call('hset', key, threadId, '1'); -- 不存在, 则获取锁
    redis.call('expire', key, releaseTime); -- 设置有效期
    return 1; -- 返回结果
end;

if(redis.call('hexists', key, threadId) == 1) then -- 锁已经存在，判断threadId是否是自己    
    redis.call('hincrby', key, threadId, '1'); -- 如果是自己，则重入次数+1
    redis.call('expire', key, releaseTime); -- 设置有效期
    return 1; -- 返回结果
end;
return 0; -- 代码走到这里,说明获取锁的不是自己，获取锁失败
```

**设计 unlock.lua 脚本**

```lua
local key = KEYS[1]; -- 第1个参数,锁的key
local threadId = ARGV[1]; -- 第2个参数,线程唯一标识

if (redis.call('HEXISTS', key, threadId) == 0) then -- 判断当前锁是否还是被自己持有
    return nil; -- 如果已经不是自己，则直接返回
end;
local count = redis.call('HINCRBY', key, threadId, -1); -- 是自己的锁，则重入次数-1

if (count == 0) then -- 判断是否重入次数是否已经为0
    redis.call('DEL', key); -- 等于0说明可以释放锁，直接删除
    return nil;    
end;
```

**在项目中集成**

**编写 RedisLock 类**

```java
@Getter
@Setter
public class RedisLock {

    private RedisTemplate redisTemplate;
    private DefaultRedisScript<Long> lockScript;
    private DefaultRedisScript<Object> unlockScript;

    public RedisLock(RedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
        // 加载释放锁的脚本
        this.lockScript = new DefaultRedisScript<>();
        this.lockScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("lock.lua")));
        this.lockScript.setResultType(Long.class);
        // 加载释放锁的脚本
        this.unlockScript = new DefaultRedisScript<>();
        this.unlockScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("unlock.lua")));
    }

    /**
     * 获取锁
     * @param lockName 锁名称
     * @param releaseTime 超时时间(单位:秒)
     * @return key 解锁标识
     */
    public String tryLock(String lockName, long releaseTime) {
        // 存入的线程信息的前缀，防止与其它JVM中线程信息冲突
        String key = UUID.randomUUID().toString();

        // 执行脚本
        Long result = (Long)redisTemplate.execute(
                lockScript,
                Collections.singletonList(lockName),
                key + Thread.currentThread().getId(), releaseTime);

        // 判断结果
        if(result != null && result.intValue() == 1) {
            return key;
        }else {
            return null;
        }
    }
    /**
     * 释放锁
     * @param lockName 锁名称
     * @param key 解锁标识
     */
    public void unlock(String lockName, String key) {
        // 执行脚本
        redisTemplate.execute(
                unlockScript,
                Collections.singletonList(lockName),
                key + Thread.currentThread().getId(), null);
    }
}
```

**初始化Bean**

```java
@Configuration
public class RedisLockConfiguration {

    @Resource
    private RedisTemplate redisTemplate;

    @Bean
    public RedisLock redisLock() {
        RedisLock redisLock = new RedisLock(redisTemplate);
        return redisLock;
    }
}
```

**分析业务修改 Mapper 和 Service**

Mapper

```java
// 根据食客 ID 和代金券 ID 及订单状态查询代金券订单
@Select("select id, order_no, fk_voucher_id, fk_diner_id, qrcode, payment," +
        " status, fk_seckill_id, order_type, create_date, update_date, " +
        " is_valid from t_voucher_orders where fk_diner_id = #{dinerId} " +
        " and fk_voucher_id = #{voucherId} and is_valid = 1 and status between 0 and 1 ")
VoucherOrders findDinerOrder(@Param("dinerId") Integer dinerId,
                             @Param("voucherId") Integer voucherId);
```

Service

```java
// 判断登录用户是否已抢到(一个用户针对这次活动只能买一次)
VoucherOrders order = voucherOrdersMapper.findDinerOrder(dinerInfo.getId(),
                                                         seckillVouchers.getFkVoucherId());
AssertUtil.isTrue(order != null, "该用户已抢到该代金券，无需再抢");
```

**修改 SeckillService 中的秒杀业务**

```java
@Resource
private RedisLock redisLock;

/**
 * 抢购代金券
 *
 * @param voucherId   代金券 ID
 * @param accessToken 登录token
 * @Para path 访问路径
 */
@Transactional(rollbackFor = Exception.class)
public ResultInfo doSeckill(Integer voucherId, String accessToken, String path) {
    // 基本参数校验
    AssertUtil.isTrue(voucherId == null || voucherId < 0, "请选择需要抢购的代金券");
    AssertUtil.isNotEmpty(accessToken, "请登录");

    // ----------注释原始的走 关系型数据库 的流程----------
    // 判断此代金券是否加入抢购
    // SeckillVouchers seckillVouchers = seckillVouchersMapper.selectVoucher(voucherId);
    // AssertUtil.isTrue(seckillVouchers == null, "该代金券并未有抢购活动");

    // ----------采用 Redis 解问题----------
    String redisKey = RedisKeyConstant.seckill_vouchers.getKey() + voucherId;
    Map<String, Object> seckillVoucherMaps = redisTemplate.opsForHash().entries(redisKey);
    SeckillVouchers seckillVouchers = BeanUtil.mapToBean(seckillVoucherMaps, SeckillVouchers.class, true, null);

    // 判断是否有效
    AssertUtil.isTrue(seckillVouchers.getIsValid() == 0, "该活动已结束");
    // 判断是否开始、结束
    Date now = new Date();
    AssertUtil.isTrue(now.before(seckillVouchers.getStartTime()), "该抢购还未开始");
    AssertUtil.isTrue(now.after(seckillVouchers.getEndTime()), "该抢购已结束");

    // 判断是否卖完通过 Lua 脚本扣库存时判断
    //AssertUtil.isTrue(seckillVouchers.getAmount() < 1, "该券已经卖完了");

    // 获取登录用户信息
    String url = oauthServerName + "user/me?access_token={accessToken}";
    ResultInfo resultInfo = restTemplate.getForObject(url, ResultInfo.class, accessToken);
    if (resultInfo.getCode() != ApiConstant.SUCCESS_CODE) {
        resultInfo.setPath(path);
        return resultInfo;
    }
    // 这里的data是一个LinkedHashMap，SignInDinerInfo
    SignInDinerInfo dinerInfo = BeanUtil.fillBeanWithMap((LinkedHashMap) resultInfo.getData(),
            new SignInDinerInfo(), false);
    // 判断登录用户是否已抢到(一个用户针对这次活动只能买一次)
    VoucherOrders order = voucherOrdersMapper.findDinerOrder(dinerInfo.getId(),
            seckillVouchers.getFkVoucherId());
    AssertUtil.isTrue(order != null, "该用户已抢到该代金券，无需再抢");

    // ----------注释原始的走 关系型数据库 的流程----------
    // 扣库存
    // int count = seckillVouchersMapper.stockDecrease(seckillVouchers.getId());
    // AssertUtil.isTrue(count == 0, "该券已经卖完了");

    // 使用 Redis 锁一个账号只能购买一次
    String lockName = RedisKeyConstant.lock_key.getKey() + dinerInfo.getId() + ":" + voucherId;
    // 加锁
    long expireTime = seckillVouchers.getEndTime().getTime() - now.getTime();
    String lockKey = redisLock.tryLock(lockName, expireTime);

    try {
        // 不为空意味着拿到锁了，执行下单
        if (StrUtil.isNotBlank(lockKey)) {
            // 下单
            VoucherOrders voucherOrders = new VoucherOrders();
            voucherOrders.setFkDinerId(dinerInfo.getId());
            // Redis 中不需要维护外键信息
            //voucherOrders.setFkSeckillId(seckillVouchers.getId());
            voucherOrders.setFkVoucherId(seckillVouchers.getFkVoucherId());
            String orderNo = IdUtil.getSnowflake(1, 1).nextIdStr();
            voucherOrders.setOrderNo(orderNo);
            voucherOrders.setOrderType(1);
            voucherOrders.setStatus(0);
            long count = voucherOrdersMapper.save(voucherOrders);
            AssertUtil.isTrue(count == 0, "用户抢购失败");

            // ----------采用 Redis 解问题----------
            // 扣库存
            // long count = redisTemplate.opsForHash().increment(redisKey, "amount", -1);
            // AssertUtil.isTrue(count < 0, "该券已经卖完了");

            // ----------采用 Redis + Lua 解问题----------
            // 扣库存
            List<String> keys = new ArrayList<>();
            keys.add(redisKey);
            keys.add("amount");
            Long amount = (Long) redisTemplate.execute(redisScript, keys);
            AssertUtil.isTrue(amount == null || amount < 1, "该券已经卖完了");
        }
    } catch (Exception e) {
        // 手动回滚事物
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
        // 解锁
        redisLock.unlock(lockName, lockKey);
        if (e instanceof ParameterException) {
            return ResultInfoUtil.buildError(0, "该券已经卖完了", path);
        }
    }

    return ResultInfoUtil.buildSuccess(path, "抢购成功");
}
```

**压力测试通过**

### 8.6、引入 Redisson 分布式锁

Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。

地址：https://github.com/redisson/redisson

它适应于多种场景：分布式应用，分布式缓存，分布式回话管理，分布式服务（任务，延迟任务，执行器），分布式redis客户端。



![img](https://gitee.com/zhao-xiaolong1/cloudeimage/raw/master/img/1615390987339-b0fabd4f-5fca-43f1-8a27-3fa61bc0f8b6.png)

在这里我们使用它分布式锁的功能。

**添加依赖**

```java
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.13.6</version>
</dependency>
```

**引入对象**

```java
@Resource
private RedissonClient redissonClient;
```

**完成代码改造**

```java
@Resource
private RedissonClient redissonClient;

/**
 * 抢购代金券
 *
 * @param voucherId   代金券 ID
 * @param accessToken 登录token
 * @Para path 访问路径
 */
@Transactional(rollbackFor = Exception.class)
public ResultInfo doSeckill(Integer voucherId, String accessToken, String path) {
    // 基本参数校验
    AssertUtil.isTrue(voucherId == null || voucherId < 0, "请选择需要抢购的代金券");
    AssertUtil.isNotEmpty(accessToken, "请登录");

    // ----------注释原始的走 关系型数据库 的流程----------
    // 判断此代金券是否加入抢购
    // SeckillVouchers seckillVouchers = seckillVouchersMapper.selectVoucher(voucherId);
    // AssertUtil.isTrue(seckillVouchers == null, "该代金券并未有抢购活动");

    // ----------采用 Redis 解问题----------
    String redisKey = RedisKeyConstant.seckill_vouchers.getKey() + voucherId;
    Map<String, Object> seckillVoucherMaps = redisTemplate.opsForHash().entries(redisKey);
    SeckillVouchers seckillVouchers = BeanUtil.mapToBean(seckillVoucherMaps, SeckillVouchers.class, true, null);

    // 判断是否有效
    AssertUtil.isTrue(seckillVouchers.getIsValid() == 0, "该活动已结束");
    // 判断是否开始、结束
    Date now = new Date();
    AssertUtil.isTrue(now.before(seckillVouchers.getStartTime()), "该抢购还未开始");
    AssertUtil.isTrue(now.after(seckillVouchers.getEndTime()), "该抢购已结束");

    // 判断是否卖完通过 Lua 脚本扣库存时判断
    //AssertUtil.isTrue(seckillVouchers.getAmount() < 1, "该券已经卖完了");

    // 获取登录用户信息
    String url = oauthServerName + "user/me?access_token={accessToken}";
    ResultInfo resultInfo = restTemplate.getForObject(url, ResultInfo.class, accessToken);
    if (resultInfo.getCode() != ApiConstant.SUCCESS_CODE) {
        resultInfo.setPath(path);
        return resultInfo;
    }
    // 这里的data是一个LinkedHashMap，SignInDinerInfo
    SignInDinerInfo dinerInfo = BeanUtil.fillBeanWithMap((LinkedHashMap) resultInfo.getData(),
            new SignInDinerInfo(), false);
    // 判断登录用户是否已抢到(一个用户针对这次活动只能买一次)
    VoucherOrders order = voucherOrdersMapper.findDinerOrder(dinerInfo.getId(),
            seckillVouchers.getFkVoucherId());
    AssertUtil.isTrue(order != null, "该用户已抢到该代金券，无需再抢");

    // ----------注释原始的走 关系型数据库 的流程----------
    // 扣库存
    // int count = seckillVouchersMapper.stockDecrease(seckillVouchers.getId());
    // AssertUtil.isTrue(count == 0, "该券已经卖完了");

    // 使用 Redis 锁一个账号只能购买一次
    String lockName = RedisKeyConstant.lock_key.getKey() + dinerInfo.getId() + ":" + voucherId;
    // 加锁
    long expireTime = seckillVouchers.getEndTime().getTime() - now.getTime();
    // 自定义 Redis 分布式锁
    // String lockKey = redisLock.tryLock(lockName, expireTime);

    // Redisson 分布式锁
    RLock lock = redissonClient.getLock(lockName);

    try {
        // 不为空意味着拿到锁了，执行下单
        // 自定义 Redis 分布式锁处理
        //if (StrUtil.isNotBlank(lockKey)) {

        // Redisson 分布式锁处理
        boolean isLocked = lock.tryLock(expireTime, TimeUnit.MILLISECONDS);
        if (isLocked) {
            // 下单
            VoucherOrders voucherOrders = new VoucherOrders();
            voucherOrders.setFkDinerId(dinerInfo.getId());
            // Redis 中不需要维护外键信息
            //voucherOrders.setFkSeckillId(seckillVouchers.getId());
            voucherOrders.setFkVoucherId(seckillVouchers.getFkVoucherId());
            String orderNo = IdUtil.getSnowflake(1, 1).nextIdStr();
            voucherOrders.setOrderNo(orderNo);
            voucherOrders.setOrderType(1);
            voucherOrders.setStatus(0);
            long count = voucherOrdersMapper.save(voucherOrders);
            AssertUtil.isTrue(count == 0, "用户抢购失败");

            // ----------采用 Redis 解问题----------
            // 扣库存
            // long count = redisTemplate.opsForHash().increment(redisKey, "amount", -1);
            // AssertUtil.isTrue(count < 0, "该券已经卖完了");

            // ----------采用 Redis + Lua 解问题----------
            // 扣库存
            List<String> keys = new ArrayList<>();
            keys.add(redisKey);
            keys.add("amount");
            Long amount = (Long) redisTemplate.execute(redisScript, keys);
            AssertUtil.isTrue(amount == null || amount < 1, "该券已经卖完了");
        }
    } catch (Exception e) {
        // 手动回滚事物
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
        // 自定义 Redis 解锁
        // redisLock.unlock(lockName, lockKey);

        // Redisson 解锁
        lock.unlock();
        if (e instanceof ParameterException) {
            return ResultInfoUtil.buildError(0, "该券已经卖完了", path);
        }
    }

    return ResultInfoUtil.buildSuccess(path, "抢购成功");
}
```

**压力测试通过**